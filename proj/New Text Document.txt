@app.post("/api/chat_m1")
@ensure_json_object

def api_chat_m1():
    sid = get_sid(request, allow_create=True)

    if not sid:
        return {
            "ok": False,
            "error": "sid Ù…ÙÙ‚ÙˆØ¯",
            "ui_hint": {"require_sid": True}
        }, 400

    sess = SESSIONS[sid]

    data = request.json or {}
    if (
        not data
        and sess.get("stage") == "started"
    ):
        return {
            "sid": sid,
            "ui_hint": {"noop": True}
        }
    original_intent = (data.get("intent") or "")
    msg_raw = data.get("message", "")
    answers_in = data.get("answers") or {}

    # ===============================
    # (A) Ø­ÙØ¸ Ø§Ù„Ù„ØºØ© ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ø®ØªØ§Ø±Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØµØ±Ø§Ø­Ø©
    # ===============================
    if isinstance(answers_in, dict) and "user_language" in answers_in:
        chosen_lang = answers_in["user_language"]
        sess["lang"] = chosen_lang
        sess["asked"].add("user_language")
        sess["stage"] = "started"

        # ğŸ”¥ FIX: Ù„Ø§ ØªÙƒÙ…Ù‘Ù„ Ø§Ù„ØªØ¯ÙÙ‚
        payload = {"sid": sid, "ask": [build_free_text_question(initial=True)]}
        return enhance_and_localize_response(payload, sess.get("lang", "ar"))
    intent = normalize_intent(original_intent, msg_raw)
    print(f"[CHAT_M1] intent={intent!r} msg={bool(msg_raw)} answers={bool(answers_in)} sid={sid}")

    # ===============================
    # (A.1) Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø´ÙŠÙƒ Ø¨ÙˆÙƒØ³ Ø¥Ù† ÙˆÙØ¬Ø¯Øª
    # ÙŠØ¯Ø¹Ù… Ø§Ù„Ø§Ø³Ù…ÙŠÙ†: symptoms_m1 (Ø§Ù„Ù…ÙˆØ­Ø¯) Ùˆ symptoms_checkbox (Ù‚Ø¯ÙŠÙ…)
    # ===============================

    if isinstance(answers_in, dict) and (
        "symptoms_m1" in answers_in or "symptoms_checkbox" in answers_in
    ):
        # Ø£ÙˆÙ„Ø§Ù‹: ÙˆØ³Ù‘Ø¹ Ø£ÙŠ Ø­Ù‚ÙˆÙ„ Ø£Ø®Ø±Ù‰ ÙƒÙ…Ø§ Ø§Ù„Ù…Ø¹ØªØ§Ø¯
        receive_answers_for_sid(sid, answers_in)

        checkbox_selected = answers_in.get("symptoms_m1") or answers_in.get("symptoms_checkbox")


        # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø±Ø³Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ø®ØªÙŠØ§Ø± Ø£Ø¹Ø±Ø§Ø¶
        if isinstance(checkbox_selected, list) and not checkbox_selected:
            # 1) Ø²Ø¯ Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ®Ø·ÙŠ
            sess["skip_count"] = int(sess.get("skip_count", 0)) + 1

            # 2) Ø§Ø·Ù„Ø¨ Ø¯ÙØ¹Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† M1 Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ asked Ø§Ù„Ø­Ø§Ù„ÙŠ
            out = generate_questions_from_columns(
                columns=m1_feature_pool(),
                asked_set=set(sess.get("asked", set())),
                batch_size=5,
                m1_scores=sess.get("M1_scores")
            )

            if isinstance(out, tuple):
                q_list, asked_updated = out
                sess["asked"] = set(asked_updated or set())
            else:
                q_list = out

            if q_list:
                ask_out = q_list if isinstance(q_list, list) else [q_list]
                ask_out = _sanitize_ask_list(ask_out)
                _mark_presented_as_asked(sess, ask_out)
                return enhance_and_localize_response({"sid": sid, "ask": ask_out}, sess.get("lang", "ar"))

            # 3) Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯ÙØ¹Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ÙˆÙ„Ø§ Ø§ÙƒØªÙØ§Ø¡ ÙƒØ§ÙÙ: Ø³Ù„ÙˆÙƒ ÙˆØ§Ø¶Ø­ ØºÙŠØ± Ù…Ø¹Ù„Ù‘Ù‚
            answers_for_stop = _build_answers_for_stop(sess)
            sufficient, _reason = m1_is_sufficient(answers_for_stop)
            dist = run_M1_on_answers(answers_for_stop) or {}
            if not sufficient:
                if sess["skip_count"] >= 3:
                    payload = {
                        "sid": sid,
                        "ask": [build_free_text_question(initial=False)],
                        "note": "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªÙ‚Ø¯Ù… Ø¯ÙˆÙ† Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ Ø£Ø¹Ø±Ø§Ø¶. Ø§ÙƒØªØ¨ Ø£Ø¹Ø±Ø§Ø¶Ùƒ Ù†ØµÙ‹Ø§ Ø£Ùˆ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…."
                    }
                    return enhance_and_localize_response(payload, sess.get("lang", "ar"))
                return enhance_and_localize_response(
                    {"sid": sid, "note": "Ø§Ø®ØªØ± Ø¹Ø±Ø¶Ù‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ø£Ùˆ Ø§ÙƒØªØ¨ Ø£Ø¹Ø±Ø§Ø¶Ùƒ Ù†ØµÙ‹Ø§."},
                    sess.get("lang", "ar")
                )





            # =========================
            # PATCH: M1 â†’ M2 (chat_m1)
            # =========================

            if dist:
                answers_canonical = canonicalize_to_m1_keys(sess["answers"], m1_feature_pool())

                # âœ… Ø­Ø³Ø§Ø¨ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø¨Ø¹Ø¯ ÙƒÙ„ checkbox
                current_dist = run_M1_on_answers(answers_canonical) or {}
                sess["M1_scores"] = current_dist

                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ù…Ø¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
                ask_out = q_list if 'q_list' in locals() else []

                # ØªÙ‡ÙŠØ¦Ø© payload Ù…Ø¤Ù‚Øª
                payload = {
                    "sid": sid,
                    "ask": ask_out,
                    "M1_distribution": dict(sorted(current_dist.items(), key=lambda x: -x[1]))
                }
                
                # Ø§Ù„Ø¢Ù† Ù†ØªØ­Ù‚Ù‚ Ù…Ù† sufficiency Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ M2
                sufficient, _ = m1_is_sufficient(answers_canonical)
                if sufficient:
                    top_dept = max(current_dist, key=current_dist.get)
                    mapped = DEPT_TO_DISEASE.get(top_dept, top_dept)
                    sess["mode"] = "M2"
                    sess["target_disease"] = mapped

                    # ØªÙˆÙ„ÙŠØ¯ ÙƒÙ„ Ø£Ø³Ø¦Ù„Ø© M2 Ù„Ù„Ù…Ø±Ø¶
                    q_all = generate_questions("M2", disease_required=[mapped], lang=sess.get("lang", "ar"))
                    missing = [
                        k for k in get_required_keys_for_disease(mapped)
                        if k.lower() not in {kk.lower() for kk in sess["answers"].keys()}
                    ]
                    q_list = [qq for qq in q_all if qq.get("name") in missing] or q_all
                    ask_out = q_list if isinstance(q_list, list) else [q_list]
                    _mark_presented_as_asked(sess, ask_out)

                    # ØªØ­Ø¯ÙŠØ« payload Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
                    payload["ask"] = ask_out

                return enhance_and_localize_response(payload, sess.get("lang", "ar"))

                

            # Ø¥Ù† Ù„Ù… ØªÙƒÙ† ÙƒØ§ÙÙŠØ©: Ù†ÙƒÙ…Ù„ Ø¨Ù…Ù†Ø·Ù‚ M1 Ø£Ø¯Ù†Ø§Ù‡...
        # Ø¥Ø°Ø§ Ù„Ù… ÙŠØªØ­Ù‚Ù‚ Ø£ÙŠ Ù…Ù…Ø§ Ø³Ø¨Ù‚ØŒ Ø§Ø³Ù…Ø­ Ù„Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± (free text / yes-no ...)

    # ===============================
    # (0) Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©: Ø³Ø¤Ø§Ù„ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹ Ø£Ùˆ Ø³Ø¤Ø§Ù„ Ù†Øµ Ø­Ø±
    # ===============================
    if (
        intent == ""
        and not msg_raw
        and not answers_in
        and sess.get("stage", "init") == "init"
        and sess["mode"] == "M1"
    ):
        if not sess.get("lang"):
            payload = {"ask": [build_language_question()], "sid": sid}
            sess["stage"] = "started"
            return payload
        else:
            payload = {"ask": [build_free_text_question(initial=True)], "sid": sid}
            sess["stage"] = "started"
            payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
            return payload

    # ===============================
    # (1) Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ø­Ø± (Ø£Ø¹Ø±Ø§Ø¶)
    # ===============================
    free_text = None
    if msg_raw:
        free_text = msg_raw
    elif isinstance(answers_in, dict) and "free_text_symptoms" in answers_in:
        free_text = str(answers_in.get("free_text_symptoms") or "").strip()

    if intent in ("", "symptoms") and free_text:
        norm = llm_normalize_user_text(free_text)
        candidate = norm.get("text_ar") or norm.get("text_en") or free_text

        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø¹Ø±Ø§Ø¶ Ù…Ù† Ø§Ù„Ù†Øµ
        extracted = {}
        try:
            if NLPAgent and nlp_agent:
                try:
                    extracted = nlp_agent.extract(candidate)
                except Exception as e:
                    print(f"[NLPAgent][EXC] {e}")
        except Exception as e:
            print(f"[NLPAgent][EXC] {e}")
            extracted = {}

        if not extracted:
            extracted = llm_extract_symptoms(candidate, m1_feature_pool()) or {}

        if not extracted:
            payload = {
                "error": "ØªØ¹Ø°Ù‘Ø± ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§. Ø§Ø°ÙƒØ± Ø£Ø¹Ø±Ø§Ø¶Ùƒ ÙˆØ§Ø­Ø¯Ø© ÙˆØ§Ø­Ø¯Ø©.",
                "ask": [build_free_text_question(initial=False)],
                "sid": sid
            }
            payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
            return payload

        # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø¥Ù„Ù‰ ØµÙŠØºØ© ØªØ¯Ø±ÙŠØ¨ M1 Ø«Ù… ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª
        canon = canonicalize_to_m1_keys(extracted, m1_feature_pool())
        receive_answers_for_sid(sid, canon)
        sess["stage"] = "in_m1"


        # ØªÙ„Ù…ÙŠØ­ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ù„ÙŠØ³Ø£Ù„: Ù‡Ù„ Ù„Ø¯ÙŠÙƒ Ø£Ø¹Ø±Ø§Ø¶ Ø£Ø®Ø±Ù‰ØŸ
        payload = {"sid": sid, "ui_hint": {"ask_more_symptoms": True}}
        payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
        return payload

    # ===============================
    # (2) Ù†Ø¹Ù… / Ù„Ø§ â€” Ù‡Ù„ Ù„Ø¯ÙŠÙƒ Ø£Ø¹Ø±Ø§Ø¶ Ø£Ø®Ø±Ù‰ØŸ
    # ===============================

    # ---- (2.1) Ù†Ø¹Ù…: Ø§Ø·Ù„Ø¨ Ù†Øµ Ø­Ø± Ø¥Ø¶Ø§ÙÙŠ
        if intent == "more_yes":
            payload = {"ask": [build_free_text_question(initial=False)], "sid": sid}
            payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
            return payload

        # ---- (2.2) Ù„Ø§: Ù‚ÙŠÙ‘Ù… Ø§Ù„Ø§ÙƒØªÙØ§Ø¡ Ø£Ùˆ Ø§Ø·Ø±Ø­ Ø´ÙŠÙƒ Ø¨ÙˆÙƒØ³ Ø¥Ø¶Ø§ÙÙŠ (Ø¨Ø¯ÙˆÙ† m1_followups)

        if intent == "more_no":
            # Ø§Ø¨Ù†Ù Ù…ØªØ¬Ù‡Ù‹Ø§ ÙƒØ«ÙŠÙÙ‹Ø§ Ù„Ù…ÙØ§ØªÙŠØ­ M1 (ÙƒÙ„ Ù…Ø§ Ù„Ù… ÙŠÙØ°ÙƒØ± = 0)
            pool = m1_feature_pool() or []
            answers_dense = canonicalize_to_m1_keys(sess["answers"], pool) or {}
            answers_dense = {k: answers_dense.get(k, 0) for k in pool}

            # Ø´Ø±Ø· Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØ¬Ù‡ Ø§Ù„ÙƒØ«ÙŠÙ
            sufficient, _reason = m1_is_sufficient(answers_dense)

            # ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø¹Ù„Ù‰ Ù†ÙØ³ Ø§Ù„Ù…ØªØ¬Ù‡
            dist = run_M1_on_answers(answers_dense) or {}

            if sufficient and dist:
                top_dept = max(dist, key=dist.get)
                disease = DEPT_TO_DISEASE.get(top_dept, top_dept)
                sess["mode"] = "M2"
                sess["target_disease"] = disease
                sess["stage"] = "in_m2"


                q_all  = generate_questions("M2", disease_required=[disease], lang=sess.get("lang", "ar"))
                missing = [
                    k for k in get_required_keys_for_disease(disease)
                    if k.lower() not in {kk.lower() for kk in sess["answers"].keys()}
                ]
                q_list = [qq for qq in q_all if qq.get("name") in missing] or q_all

                payload = {
                    "top_department": top_dept,
                    "target_disease": disease,
                    "ask": q_list,
                    "sid": sid,
                    "note": "ØªÙ… Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù„Ø£Ø¹Ø±Ø§Ø¶ ÙƒØ§ÙÙŠØ© Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©."
                }
                return enhance_and_localize_response(payload, sess.get("lang", "ar"))

            # Ø®Ù„Ø§Ù Ø°Ù„Ùƒ: ØªØ§Ø¨Ø¹ Ø¨Ø¯ÙØ¹Ø§Øª M1 Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„ÙˆØ­ÙŠØ¯
            out = generate_questions_from_columns(
                columns=m1_feature_pool(),
                asked_set=set(sess.get("asked", set())),
                batch_size=5,
                m1_scores=dist
            )
            if isinstance(out, tuple):
                res, asked = out
            else:
                res, asked = out, sess.get("asked", set())

            sess["asked"] = set(asked or set())

            if isinstance(res, list):
                ask_list = res
            elif res:
                ask_list = [res]
            else:
                ask_list = []

            payload = {"ask": ask_list, "sid": sid, "note": "Ù†Ø­ØªØ§Ø¬ Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªØ§Ù„ÙŠ."}
            return enhance_and_localize_response(payload, sess.get("lang", "ar"))

            # 5) Ø®Ù„Ø§Ù Ø°Ù„Ùƒ: Ø§Ø·Ø±Ø­ Ø¯ÙØ¹Ø© Ø´ÙŠÙƒ Ø¨ÙˆÙƒØ³ M1 Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„ÙˆØ­ÙŠØ¯

            out = generate_questions_from_columns(
                columns=m1_feature_pool(),
                asked_set=set(sess.get("asked", set())),
                batch_size=5,
                m1_scores=dist
            )

            # ÙÙƒÙ‘ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø¨Ø£Ù…Ø§Ù†
            if isinstance(out, tuple):
                res, asked = out
            else:
                res = out
                asked = sess.get("asked", set())

            # Ø®Ø²Ù‘Ù† asked Ø¨Ø£Ù…Ø§Ù†
            try:
                sess["asked"] = set(asked or set())
            except Exception:
                # fallback Ø­ØªÙ‰ Ù„Ùˆ Ù„Ù… ØªÙƒÙ† Ù…Ø¬Ù…ÙˆØ¹Ø©
                sess["asked"] = set(list(asked)) if asked else set()

            # ØªØ­Ø¶ÙŠØ± ask ÙƒÙ‚Ø§Ø¦Ù…Ø© Ø¯Ø§Ø¦Ù…Ù‹Ø§
            if isinstance(res, list):
                ask_list = res                       # Ø§Ù„Ø¯Ø§Ù„Ø© Ø£Ø¹Ø§Ø¯Øª Ù‚Ø§Ø¦Ù…Ø© Ø£Ø³Ø¦Ù„Ø©
            elif res:
                ask_list = [res]                     # Ø§Ù„Ø¯Ø§Ù„Ø© Ø£Ø¹Ø§Ø¯Øª Ø³Ø¤Ø§Ù„Ù‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ (dict)
            else:
                ask_list = []                        # Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¤Ø§Ù„

            payload = {
                "ask": ask_list,
                "sid": sid,
                "note": "Ù†Ø­ØªØ§Ø¬ Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªØ§Ù„ÙŠ."
            }
            payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
            return payload

        # ===============================
        # Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: Ø£Ø¹ÙØ¯ Ø³Ø¤Ø§Ù„ Ù†Øµ Ø­Ø± Ø£ÙˆÙ„ÙŠ/Ø¥Ø¶Ø§ÙÙŠ Ø­Ø³Ø¨ Ø§Ù„Ù„ØºØ©
        # ===============================

        # Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ø¥Ù† Ø±ØºØ¨Øª Ø§Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø°ÙŠÙ„
        if 'payload' not in locals():
            payload = {"sid": sid, "ui_hint": {"noop": True}}

        payload = enhance_and_localize_response(payload, sess.get("lang", "ar"))
        return payload
